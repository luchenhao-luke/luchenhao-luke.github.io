<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法题Day2</title>
      <link href="/2023/11/30/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5Day2/"/>
      <url>/2023/11/30/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5Day2/</url>
      
        <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第二天-977-有序数组的平方、209-长度最小的子数组、59-螺旋矩阵II。"><a href="#代码随想录算法训练营第二天-977-有序数组的平方、209-长度最小的子数组、59-螺旋矩阵II。" class="headerlink" title="代码随想录算法训练营第二天| 977. 有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。"></a>代码随想录算法训练营第二天| 977. 有序数组的平方、209.长度最小的子数组、59.螺旋矩阵II。</h1><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a>977. 有序数组的平方</h2><ul><li><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">题目链接</a></p><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p></li></ul><p>  示例 1：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><p>  示例 2：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><ul><li><p>题解：1. <strong>有序数组</strong> 2. <strong>平方之后排序</strong></p></li><li><p>视频总结：</p><ul><li><u><code>平方之后最大元素一定是在两边</code></u>，数组从两边往里慢慢缩小</li><li>返回新数组，不要求空间复杂度</li></ul></li><li><p>个人思路：<code>sorted(x*x for x in nums)</code></p></li><li><p>难点：</p><ul><li>平方之后最大的元素一定在两边</li><li>想到头尾双指针操作</li></ul></li><li><p>学习时长：40mins</p></li><li><p>动画：</p></li><li><p><img src="977.有序数组的平方-20231204154122901.gif" alt="img"></p></li><li><p>LeetCode代码：</p><ul><li><p>第一种解法(暴力排序)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力解法，先平方，后排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] *= nums[i]</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><hr><p><em>时间复杂度：</em>$O(n+nlogn)$</p></li><li><p>第二种解法(双指针法)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        res = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * <span class="built_in">len</span>(nums) <span class="comment"># 需要提前定义列表，存放结果</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j : <span class="comment"># i等于j的时候，还有一个元素要计算之后传入新数组，所以不能落下</span></span><br><span class="line">            <span class="keyword">if</span> nums[j] * nums[j] &gt;= nums[i] * nums[i]:</span><br><span class="line">                res[k] = nums[j] * nums[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[k] = nums[i] * nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><p><em>时间复杂度：</em>$O(n)$</p></li></ul></li></ul><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h2><ul><li><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">题目链接</a></p><p>  给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>  找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p>  <strong>示例 1：</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p>  <strong>示例 2：</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>  <strong>示例 3：</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure></li><li><p>题解：1. 动态调节大小的滑动窗口（伸缩滑动窗口）</p></li><li><p>视频总结：</p><ul><li>如何用一个for循环做两个for循环的事情 -&gt; “滑动窗口”</li><li>for循环的j指向的是终止位置而非起始位置</li><li>while表示的是一个持续向后移动滑动窗口并且更新窗口大小的过程</li></ul></li><li><p>个人思路：暴力解法（leetcode判题超时）</p></li><li><p>难点：</p><ul><li>滑动窗口“伸出去”、“缩回来”</li></ul></li><li><p>总结：滑动窗口的大小不是固定的，而是通过“伸出去”“缩回来”两个步骤不断更新的动态大小</p></li><li><p>学习时长：30mins</p></li><li><p>LeetCode代码：</p><ul><li><p>暴力解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_ = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="comment"># 一个for循环控制起始位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            cur_sum = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 一个for循环控制终止位置</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(nums)):</span><br><span class="line">                cur_sum += nums[j]</span><br><span class="line">                <span class="keyword">if</span> cur_sum &gt;= target:</span><br><span class="line">                    min_ = <span class="built_in">min</span>(min_, j-i+<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> min_ == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> min_</span><br></pre></td></tr></table></figure><hr><p><em>时间复杂度：</em>$O(n^2)$ -&gt; 两个嵌套循环</p><p><em>空间复杂度</em>：$O(1)$</p><p><img src="截屏2023-12-04 16.09.09.png" alt="截屏2023-12-04 16.09.09" style="zoom: 50%;" /></p></li><li><p>滑动窗口法：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_len = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            cur_sum += nums[j]</span><br><span class="line">            <span class="keyword">while</span> cur_sum &gt;= target :</span><br><span class="line">                cur_sum -= nums[i]</span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, j - i + <span class="number">1</span>)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> min_len == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> min_len</span><br></pre></td></tr></table></figure><hr><p>  <em>时间复杂度：</em>$O(n)$ -&gt; 不要以为for里放一个while就以为是$O(n^2)$啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 $2 × n$ 也就是$O(n)$。</p><p>  <em>空间复杂度：</em>$O(1)$</p></li></ul></li></ul><h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59. 螺旋矩阵II"></a>59. 螺旋矩阵II</h2><ul><li><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">题目链接</a></p><p>  给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p>  <strong>示例 1：</strong></p><p>  <img src="spiraln.jpg" alt="img"></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p>  <strong>示例 2：</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure></li><li><p>题解：1. 哪条边的数据就归哪条边处理，不要乱 2. 永远左闭右开</p></li><li><p>视频总结：</p><ul><li>如何用一个for循环做两个for循环的事情 -&gt; “滑动窗口”</li><li>for循环的j指向的是终止位置而非起始位置</li><li>while表示的是一个持续向后移动滑动窗口并且更新窗口大小的过程</li></ul></li><li><p>个人思路：暴力解法（leetcode判题超时）</p></li><li><p>难点：</p><ul><li>滑动窗口“伸出去”、“缩回来”</li></ul></li><li><p>总结：滑动窗口的大小不是固定的，而是通过“伸出去”“缩回来”两个步骤不断更新的动态大小</p></li><li><p>学习时长：30mins</p></li><li><p>LeetCode代码：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题Day1</title>
      <link href="/2023/11/29/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5Day1/"/>
      <url>/2023/11/29/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5Day1/</url>
      
        <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第一天-704-二分查找、27-移除元素。"><a href="#代码随想录算法训练营第一天-704-二分查找、27-移除元素。" class="headerlink" title="代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。"></a><strong>代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素</strong>。</h1><h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2><blockquote><p><u>使用别人编写的算法时，知道运行时间是很有帮助的！</u></p></blockquote><ol><li>数据规模n，操作单元数f(n)，算法时间增长率和f(n)的增长率相同，这个增长率为O(f(n))，O学术上表示上界，业内一般表示“一般情况”，即数据形式一般的情况。<ul><li>可忽略常数项原因为，通常认为数据量级非常庞大，常数项系数不起决定作用</li><li>大O表示法log可以以任何数字为底，因为<script type="math/tex">log_2^N=log_2^{10}*log_{10}^N</script></li><li>线性时间(linear time)：最多需要猜测的次数与列表长度相同 -&gt; O(n)</li><li>对数时间(log time)：二分查找对应的运行时间为对数时间 -&gt; O(log_n)</li><li>时间排序：指数阶$O(n!)$ &gt; 立方阶$O(n^3)$ &gt; 平方阶$O(n^2)$ &gt; 线性对数阶$O(n*logn)$ &gt; 线性阶$O(n)$ &gt; 对数阶$O(logn)$ &gt; 常数阶$O(C)$</li></ul></li><li>大O表示法的意义在于，通过函数式告诉你运行时间的增速，即随着n增大，时间增长的==幅度==不同<ul><li>大O表示法算出的结果是操作数，n是要处理的元素数量，然后除以每秒可执行的操作得到需要的时间</li><li>大O表示法指出的运行时间是最糟情况下的运行时间，是上限；还有平均情况下的运行时间也要考虑</li></ul></li></ol><p><img src="大O表示法.svg" alt="大O表示法"></p><h2 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h2><ol><li><strong>数组是存放在连续内存空间上的相同类型数据的集合</strong></li><li><strong>数组内存空间的地址是连续的</strong></li><li><strong>数组的元素是不能删的，只能覆盖。</strong></li><li><strong>删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></li></ol><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h2><ul><li><p><a href="https://leetcode.cn/problems/binary-search/">题目链接</a></p></li><li><p>题解：1. <strong>有序数组</strong> 2. <strong>无重复元素</strong></p></li><li><p>视频总结：</p><ul><li><code>while</code>循环的控制条件符号$&lt;$、$&lt;=$</li><li>边界条件<code>right = middle</code> or <code>right = middle - 1</code></li><li>选择<code>左闭右开</code>或者<code>左闭右闭</code></li></ul></li><li><p>个人思路：全都使用闭合区间，每一次做判断的时候+1或者-1</p></li><li><p>难点：</p><ul><li>区间搜索的时候要明确区间定义：左闭右闭[]还是左闭右开[)？左开右闭比较少见。。</li><li>边界处理，left&lt;right还是left&lt;=right,right=middle还是right=middle-1</li><li>循环中根据区间定义做边界处理，就是循环不变量规则：在while循环中坚持一个区间，区间即不变量</li></ul></li><li><p>学习时长：30mins</p></li><li><p>代码展示(伪代码)：</p><ul><li><p>第一种写法（左闭右闭）</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左闭右闭，合法区间的话left可能等于right</span></span><br><span class="line">left = <span class="number">0</span>, right = numsize - <span class="number">1</span>, target</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)：</span><br><span class="line">    middle = (left + right)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[middle] &gt; target:</span><br><span class="line">        right = middle - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">        left = middle + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> middle</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p>  <em>时间复杂度：</em>$O(logn)$ -&gt; 对于包含n个元素的列表，用二分查找最多需要log2_n步，而简单的从头到尾查找需要n步。</p><p>  <em>空间复杂度：</em>$O(1)$</p></li><li><p>第二种写法（左闭右开）</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左闭右开， 合法区间的话left要小于right</span></span><br><span class="line">left = <span class="number">0</span>, right = numsize, target</span><br><span class="line"><span class="keyword">while</span>(left &lt; right)：</span><br><span class="line">    middle = (left + right)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[middle] &gt; target:</span><br><span class="line">        right = middle</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">        left = middle + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> middle</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p>  <em>时间复杂度：</em>$O(logn)$ -&gt; 对于包含n个元素的列表，用二分查找最多需要log2_n步，而简单的从头到尾查找需要n步。</p><p>  <em>空间复杂度：</em>$O(1)$</p></li></ul></li><li><p>LeetCode代码：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">            middle = (left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target):</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (nums[middle] &lt; target):</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><ul><li><p><a href="https://leetcode.cn/problems/remove-element/">题目链接</a></p></li><li><p>题解：1. <strong>限制O(1)的空间复杂度</strong></p></li><li><p>视频总结：</p><ul><li>数组元素不能删除，只能覆盖，物理内存空间不会发生改变，原来的位置多余出来变成了垃圾</li><li>如果使用库函数可以非常方便的完成解题，则不要使用库函数，除非对库函数内部实现和复杂度很清楚</li><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组；慢指针：指向更新 新数组下标的位置</li></ul></li><li><p>个人思路：暴力解法</p></li><li><p>难点：</p><ul><li>如何用一个for循环完成两个for循环的工作</li></ul></li><li><p>总结：相比于暴力解法来说，双指针解法找的是不等于的情况（找需要的元素）暴力解法找的是等于的情况（找要排除的元素）</p></li><li><p>学习时长：30mins</p></li><li><p>LeetCode代码：</p><ul><li><p>暴力解法</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, j): <span class="comment">#range右边是开区间，因此取不到，所以j=len(nums)而不是len(nums)-1</span></span><br><span class="line">                    nums[k-<span class="number">1</span>] = nums[k] <span class="comment">#后面整体往前移动一位</span></span><br><span class="line">                i -= <span class="number">1</span> <span class="comment">#因为元素被删掉之后，整体往前移动了，当前位置变成了一个新的数，所以还是要从当前位置开始查找，因此这里-1</span></span><br><span class="line">                j -= <span class="number">1</span> <span class="comment">#因为整体往前移动了，所以尾部缩短一位</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><hr><p>  <em>时间复杂度：</em>$O(n^2)$ -&gt; 两个循环，遍历两遍</p><p>  <em>空间复杂度：</em>$O(1)$</p></li><li><p>双指针法：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow = fast = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">        nums[slow] = nums[fast]</span><br><span class="line">        slow += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow <span class="comment">#slow正好在新数组index+1的位置上，所以就等于新数组的长度</span></span><br></pre></td></tr></table></figure><hr><p>  <em>时间复杂度：</em>$O(n)$ </p><p>  <em>空间复杂度：</em>$O(1)$</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
