<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法题Day1</title>
      <link href="/2023/11/29/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5Day1/"/>
      <url>/2023/11/29/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5Day1/</url>
      
        <content type="html"><![CDATA[<h1 id="代码随想录算法训练营第一天-704-二分查找、27-移除元素。"><a href="#代码随想录算法训练营第一天-704-二分查找、27-移除元素。" class="headerlink" title="代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。"></a><strong>代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素</strong>。</h1><h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2><blockquote><p><u>使用别人编写的算法时，知道运行时间是很有帮助的！</u></p></blockquote><ol><li>数据规模n，操作单元数f(n)，算法时间增长率和f(n)的增长率相同，这个增长率为O(f(n))，O学术上表示上界，业内一般表示“一般情况”，即数据形式一般的情况。<ul><li>可忽略常数项原因为，通常认为数据量级非常庞大，常数项系数不起决定作用</li><li>大O表示法log可以以任何数字为底，因为<script type="math/tex">log_2^N=log_2^{10}*log_{10}^N</script></li><li>线性时间(linear time)：最多需要猜测的次数与列表长度相同 -&gt; O(n)</li><li>对数时间(log time)：二分查找对应的运行时间为对数时间 -&gt; O(log_n)</li><li>时间排序：指数阶$O(n!)$ &gt; 立方阶$O(n^3)$ &gt; 平方阶$O(n^2)$ &gt; 线性对数阶$O(n*logn)$ &gt; 线性阶$O(n)$ &gt; 对数阶$O(logn)$ &gt; 常数阶$O(C)$</li></ul></li><li>大O表示法的意义在于，通过函数式告诉你运行时间的增速，即随着n增大，时间增长的==幅度==不同<ul><li>大O表示法算出的结果是操作数，n是要处理的元素数量，然后除以每秒可执行的操作得到需要的时间</li><li>大O表示法指出的运行时间是最糟情况下的运行时间，是上限；还有平均情况下的运行时间也要考虑</li></ul></li></ol><p><img src="大O表示法.svg" alt="大O表示法"></p><h2 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h2><ol><li><strong>数组是存放在连续内存空间上的相同类型数据的集合</strong></li><li><strong>数组内存空间的地址是连续的</strong></li><li><strong>数组的元素是不能删的，只能覆盖。</strong></li><li><strong>删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></li></ol><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h2><ul><li><p><a href="">题目链接</a></p></li><li><p>题解：1. <strong>有序数组</strong> 2. <strong>无重复元素</strong></p></li><li><p>视频总结：</p><ul><li><code>while</code>循环的控制条件符号$&lt;$、$&lt;=$</li><li>边界条件<code>right = middle</code> or <code>right = middle - 1</code></li><li>选择==左闭右开==或者==左闭右闭==</li></ul></li><li><p>个人思路：全都使用闭合区间，每一次做判断的时候+1或者-1</p></li><li><p>难点：</p><ul><li>区间搜索的时候要明确区间定义：左闭右闭[]还是左闭右开[)？左开右闭比较少见。。</li><li>边界处理，left&lt;right还是left&lt;=right,right=middle还是right=middle-1</li><li>循环中根据区间定义做边界处理，就是循环不变量规则：在while循环中坚持一个区间，区间即不变量</li></ul></li><li><p>学习时长：30mins</p></li><li><p>代码展示(伪代码)：</p><ul><li><p>第一种写法（左闭右闭）</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左闭右闭，合法区间的话left可能等于right</span></span><br><span class="line">left = <span class="number">0</span>, right = numsize - <span class="number">1</span>, target</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)：</span><br><span class="line">    middle = (left + right)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[middle] &gt; target:</span><br><span class="line">        right = middle - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">        left = middle + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> middle</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p>  <em>时间复杂度：</em>$O(logn)$ -&gt; 对于包含n个元素的列表，用二分查找最多需要log2_n步，而简单的从头到尾查找需要n步。</p><p>  <em>空间复杂度：</em>$O(1)$</p></li><li><p>第二种写法（左闭右开）</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左闭右开， 合法区间的话left要小于right</span></span><br><span class="line">left = <span class="number">0</span>, right = numsize, target</span><br><span class="line"><span class="keyword">while</span>(left &lt; right)：</span><br><span class="line">    middle = (left + right)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[middle] &gt; target:</span><br><span class="line">        right = middle</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">        left = middle + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> middle</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p>  <em>时间复杂度：</em>$O(logn)$ -&gt; 对于包含n个元素的列表，用二分查找最多需要log2_n步，而简单的从头到尾查找需要n步。</p><p>  <em>空间复杂度：</em>$O(1)$</p></li></ul></li><li><p>LeetCode代码：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">            middle = (left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target):</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (nums[middle] &lt; target):</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><ul><li><p><a href="">题目链接</a></p></li><li><p>题解：1. <strong>限制O(1)的空间复杂度</strong></p></li><li><p>视频总结：</p><ul><li>数组元素不能删除，只能覆盖，物理内存空间不会发生改变，原来的位置多余出来变成了垃圾</li><li>如果使用库函数可以非常方便的完成解题，则不要使用库函数，除非对库函数内部实现和复杂度很清楚</li><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组；慢指针：指向更新 新数组下标的位置</li></ul></li><li><p>个人思路：暴力解法</p></li><li><p>难点：</p><ul><li>如何用一个for循环完成两个for循环的工作</li></ul></li><li><p>总结：相比于暴力解法来说，双指针解法找的是不等于的情况（找需要的元素）暴力解法找的是等于的情况（找要排除的元素）</p></li><li><p>学习时长：30mins</p></li><li><p>LeetCode代码：</p><ul><li><p>暴力解法</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, j): <span class="comment">#range右边是开区间，因此取不到，所以j=len(nums)而不是len(nums)-1</span></span><br><span class="line">                    nums[k-<span class="number">1</span>] = nums[k] <span class="comment">#后面整体往前移动一位</span></span><br><span class="line">                i -= <span class="number">1</span> <span class="comment">#因为元素被删掉之后，整体往前移动了，当前位置变成了一个新的数，所以还是要从当前位置开始查找，因此这里-1</span></span><br><span class="line">                j -= <span class="number">1</span> <span class="comment">#因为整体往前移动了，所以尾部缩短一位</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><hr><p>  <em>时间复杂度：</em>$O(n^2)$ -&gt; 两个循环，遍历两遍</p><p>  <em>空间复杂度：</em>$O(1)$</p></li><li><p>双指针法：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow = fast = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">        nums[slow] = nums[fast]</span><br><span class="line">        slow += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow <span class="comment">#slow正好在新数组index+1的位置上，所以就等于新数组的长度</span></span><br></pre></td></tr></table></figure><hr><p>  <em>时间复杂度：</em>$O(n)$ </p><p>  <em>空间复杂度：</em>$O(1)$</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
